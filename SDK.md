
### Communication Model

The Wing console uses an asynchronous communication model:

1. You make requests using methods like `requestNodeDefinition()` and `requestNodeData()`
2. Responses come back through callback functions you register

### IDs and Names

Nodes are identified by numeric IDs. You can convert between IDs and names:

```rust
uint32_t id = WingConsole::nodeNameToId(name);  // Returns the ID for this node
```
and
```rust
std::string name = WingConsole::nodeIdToName(id);  // Returns the ID for this node
```

The mapping of name to ID is generated by the `wingschema` utility and is
pulled into the lirbary at compile time. It is quite large (over 35k entries as
of firmware 3.0.5), and adds about 1MB to the library size. If you need this
trimmed and can give up this name/id mapping, just delete all (or some) of the
rows in `wing-schema.cpp`.

### Reading Data

To start receiving data:

```rust
wing.read();  // This blocks and processes incoming messages
```

You can request data from the Wing:

```rust
// Request a node definition -- this is the schema of the node.
// You can pass zero (0) to get the root nodes.
wing.requestNodeDefinition(id);
```

```rust
// Request a node's data -- this is the parameter value.
wing.requestNodeData(id);
```

These methods can be called on any thread.

### Writing Data

To change values on the console:

```rust
// Set values by node ID
console.setString(nodeId, "value");
console.setFloat(nodeId, 0.5f);
console.setInt(nodeId, 42);
```

These methods can be called on any thread.

## Example Programs

### wingmon
The `wingmon` program demonstrates basic connection and monitoring:
- Discovers consoles on the network
- Connects to the first one found
- Monitors and displays value changes

### wingschema 
The `wingschema` program shows how to:
- Traverse the entire node tree
- Request and process node definitions
- Generate documentation of the console's parameter space
- Handle asynchronous responses systematically
